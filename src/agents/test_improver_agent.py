"""
Test Improver Agent - Generates improved version of test code based on analysis.
"""

import logging
from typing import Dict

logger = logging.getLogger(__name__)


class TestImproverAgent:
    """Agent responsible for improving test code based on analysis."""
    
    def __init__(self):
        """Initialize test improver agent."""
        logger.info("Test Improver Agent initialized")
    
    def generate_improved_test_suite(
        self,
        analysis_result: Dict,
        original_code: str
    ) -> str:
        """
        Generate improved test suite based on analysis.
        
        Args:
            analysis_result: Analysis result from TestAnalyzerAgent
            original_code: Original test code
        
        Returns:
            Improved test code as string
        """
        logger.info("Generating improved test suite...")
        
        # Check if analysis result has the expected structure
        if 'test_methods' in analysis_result:
            # Standard structure with test_methods
            return self._generate_from_standard_structure(analysis_result, original_code)
        elif 'suggested_code' in analysis_result:
            # Flat structure with single suggested_code (fallback from some models)
            logger.warning("Analysis result has flat structure, using suggested_code directly")
            return analysis_result['suggested_code']
        else:
            # Completely unexpected structure
            logger.error("Analysis result has unexpected structure, returning original code")
            return original_code
    
    def _generate_from_standard_structure(
        self,
        analysis_result: Dict,
        original_code: str
    ) -> str:
        """Generate improved code from standard analysis structure."""
        # Extract test class name
        test_class_name = analysis_result.get('test_class_name', 'UnknownTestClass')
        
        # Build improved code from suggested_code of each method
        improved_code_parts = []
        
        # Add header comment
        improved_code_parts.append(
            f"/**\n"
            f" * Improved Test Suite: {test_class_name}\n"
            f" * Generated by TAI-EvalGenTCS\n"
            f" * Overall Compliance Score: {analysis_result.get('overall_compliance_score', 'N/A')}\n"
            f" */\n"
        )
        
        # Extract class declaration from original code
        class_declaration = self._extract_class_declaration(original_code)
        if class_declaration:
            improved_code_parts.append(class_declaration)
            improved_code_parts.append("\n")
        
        # Add improved test methods
        test_methods = analysis_result.get('test_methods', [])
        if test_methods:
            for method in test_methods:
                suggested_code = method.get('suggested_code', '')
                if suggested_code:
                    improved_code_parts.append(f"    {suggested_code}\n\n")
        else:
            logger.warning("No test methods found in analysis result")
        
        # Add closing brace
        improved_code_parts.append("}\n")
        
        improved_code = ''.join(improved_code_parts)
        
        logger.info(f"Generated improved test suite ({len(improved_code)} chars)")
        
        return improved_code
    
    def _extract_class_declaration(self, original_code: str) -> str:
        """
        Extract class declaration and imports from original code.
        
        Args:
            original_code: Original test code
        
        Returns:
            Class declaration with imports
        """
        lines = original_code.split('\n')
        declaration_parts = []
        in_class = False
        
        for line in lines:
            # Add imports and package declarations
            if line.strip().startswith('package ') or \
               line.strip().startswith('import ') or \
               line.strip().startswith('//') or \
               line.strip().startswith('/*') or \
               line.strip() == '':
                declaration_parts.append(line)
            
            # Add class declaration
            elif 'class ' in line and not in_class:
                # Extract just the class declaration line
                if '{' in line:
                    declaration_parts.append(line.split('{')[0] + '{')
                else:
                    declaration_parts.append(line)
                in_class = True
                break
        
        return '\n'.join(declaration_parts)
    
    def generate_improvement_summary(self, analysis_result: Dict) -> str:
        """
        Generate summary of improvements made.
        
        Args:
            analysis_result: Analysis result from TestAnalyzerAgent
        
        Returns:
            Summary as formatted string
        """
        test_class_name = analysis_result.get('test_class_name', 'Unknown')
        overall_score = analysis_result.get('overall_compliance_score', 'N/A')
        
        summary = f"# Test Suite Improvement Summary\n"
        summary += f"## Test Class: {test_class_name}\n"
        summary += f"## Overall Compliance Score: {overall_score}\n\n"
        
        # Practices summary
        summary += "## Best Practices Compliance\n\n"
        
        practices_report = analysis_result.get('practices_report', [])
        if practices_report:
            for practice in practices_report:
                code = practice.get('practice_code', 'N/A')
                title = practice.get('practice_title', 'N/A')
                compliance = practice.get('compliance_score', 'N/A')
                summary += f"- **{code}**: {title} - {compliance}\n"
        else:
            summary += "*No practices report available*\n"
        
        # Method-level improvements
        summary += "\n## Method-Level Improvements\n\n"
        
        test_methods = analysis_result.get('test_methods', [])
        if test_methods:
            for method in test_methods:
                method_name = method.get('test_method_name', 'Unknown')
                method_score = method.get('method_compliance_score', 'N/A')
                summary += f"### {method_name} (Score: {method_score})\n\n"
                
                # List non-compliant practices
                practices_eval = method.get('practices_evaluation', [])
                non_compliant = [p for p in practices_eval if p.get('status') == '‚ùå']
                
                if non_compliant:
                    summary += "**Issues Found:**\n"
                    for practice in non_compliant:
                        code = practice.get('practice_code', 'N/A')
                        justification = practice.get('justification', 'N/A')
                        summary += f"- **{code}**: {justification}\n"
                    summary += "\n"
        else:
            summary += "*No method-level information available*\n"
        
        return summary
