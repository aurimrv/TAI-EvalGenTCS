"""
Test Improver Agent - Generates improved version of test code based on analysis.
"""

import logging
import re
from typing import Dict

logger = logging.getLogger(__name__)


class TestImproverAgent:
    """Agent responsible for improving test code based on analysis."""
    
    def __init__(self):
        """Initialize test improver agent."""
        logger.info("Test Improver Agent initialized")
    
    def generate_improved_test_suite(
        self,
        analysis_result: Dict,
        original_code: str
    ) -> str:
        """
        Generate improved test suite based on analysis.
        
        Args:
            analysis_result: Analysis result from TestAnalyzerAgent
            original_code: Original test code
        
        Returns:
            Improved test code as string
        """
        logger.info("Generating improved test suite...")
        
        # Check if analysis result has the expected structure
        if 'test_methods' in analysis_result:
            # Standard structure with test_methods
            return self._generate_from_standard_structure(analysis_result, original_code)
        elif 'suggested_code' in analysis_result:
            # Flat structure with single suggested_code (fallback from some models)
            logger.warning("Analysis result has flat structure, using suggested_code directly")
            improved_code = analysis_result['suggested_code']
            # Ensure original class name is preserved
            return self._preserve_original_class_name(improved_code, original_code)
        else:
            # Completely unexpected structure
            logger.error("Analysis result has unexpected structure, returning original code")
            return original_code
    
    def _generate_from_standard_structure(
        self,
        analysis_result: Dict,
        original_code: str
    ) -> str:
        """Generate improved code from standard analysis structure."""
        test_methods = analysis_result.get('test_methods', [])
        
        if not test_methods:
            logger.warning("No test methods found in analysis result")
            return original_code
        
        # Strategy 1: Check if the first method has a complete class in suggested_code
        # (Some LLMs return the complete improved class in the first method's suggested_code)
        first_method_code = test_methods[0].get('suggested_code', '')
        
        if first_method_code and 'class ' in first_method_code:
            logger.info("Using complete class from first method's suggested_code")
            improved_code = self._clean_suggested_code(first_method_code)
            # Ensure original class name is preserved
            return self._preserve_original_class_name(improved_code, original_code)
        
        # Strategy 2: Build the class from individual method improvements
        logger.info("Building improved class from individual method suggestions")
        return self._build_class_from_methods(analysis_result, original_code)
    
    def _build_class_from_methods(
        self,
        analysis_result: Dict,
        original_code: str
    ) -> str:
        """Build improved class by combining individual method improvements."""
        # Extract original class name
        original_class_name = self._extract_class_name(original_code)
        
        # Extract test class name from analysis
        test_class_name = analysis_result.get('test_class_name', original_class_name)
        
        # Build improved code
        improved_code_parts = []
        
        # Add header comment
        improved_code_parts.append(
            f"/**\n"
            f" * Improved Test Suite: {original_class_name}\n"
            f" * Generated by TAI-EvalGenTCS\n"
            f" * Overall Compliance Score: {analysis_result.get('overall_compliance_score', 'N/A')}\n"
            f" */\n"
        )
        
        # Extract package, imports, and class declaration from original code
        class_header = self._extract_class_header(original_code)
        improved_code_parts.append(class_header)
        improved_code_parts.append("\n")
        
        # Add improved test methods
        test_methods = analysis_result.get('test_methods', [])
        for method in test_methods:
            suggested_code = method.get('suggested_code', '').strip()
            if suggested_code:
                # Clean up the suggested code (remove any class declarations if present)
                cleaned_code = self._extract_method_only(suggested_code)
                if cleaned_code:
                    improved_code_parts.append(f"    {cleaned_code}\n\n")
        
        # Add closing brace
        improved_code_parts.append("}\n")
        
        improved_code = ''.join(improved_code_parts)
        
        logger.info(f"Generated improved test suite ({len(improved_code)} chars)")
        
        return improved_code
    
    def _clean_suggested_code(self, code: str) -> str:
        """
        Clean suggested code by removing comments, extra whitespace, etc.
        
        Args:
            code: Suggested code from LLM
        
        Returns:
            Cleaned code
        """
        # Remove code block markers if present
        code = re.sub(r'^```java\s*', '', code, flags=re.MULTILINE)
        code = re.sub(r'^```\s*$', '', code, flags=re.MULTILINE)
        
        # Remove excessive blank lines
        code = re.sub(r'\n\n\n+', '\n\n', code)
        
        return code.strip()
    
    def _extract_method_only(self, code: str) -> str:
        """
        Extract only method code, removing any class declarations.
        
        Args:
            code: Code that might contain class declarations
        
        Returns:
            Method code only
        """
        # If the code contains a class declaration, it's a full class, not a method
        if 'class ' in code and '{' in code:
            logger.warning("Suggested code contains full class, not just method")
            return ""
        
        return code.strip()
    
    def _extract_class_name(self, code: str) -> str:
        """
        Extract class name from Java code.
        
        Args:
            code: Java source code
        
        Returns:
            Class name
        """
        # Match: public class ClassName or class ClassName
        match = re.search(r'(?:public\s+)?class\s+(\w+)', code)
        if match:
            return match.group(1)
        return "UnknownTestClass"
    
    def _extract_class_header(self, code: str) -> str:
        """
        Extract package, imports, and class declaration from original code.
        
        Args:
            code: Original test code
        
        Returns:
            Class header (package + imports + class declaration)
        """
        lines = code.split('\n')
        header_parts = []
        in_class = False
        
        for line in lines:
            # Add package declarations
            if line.strip().startswith('package '):
                header_parts.append(line)
            
            # Add imports
            elif line.strip().startswith('import '):
                header_parts.append(line)
            
            # Add comments before class
            elif line.strip().startswith('//') or \
                 line.strip().startswith('/*') or \
                 line.strip().startswith('*'):
                header_parts.append(line)
            
            # Add empty lines
            elif line.strip() == '':
                header_parts.append(line)
            
            # Add class declaration
            elif 'class ' in line and not in_class:
                # Extract just the class declaration line (without the body)
                if '{' in line:
                    header_parts.append(line.split('{')[0] + '{')
                else:
                    header_parts.append(line)
                in_class = True
                break
        
        return '\n'.join(header_parts)
    
    def _preserve_original_class_name(self, improved_code: str, original_code: str) -> str:
        """
        Ensure the improved code uses the original class name.
        
        Args:
            improved_code: Improved code (might have wrong class name)
            original_code: Original code (with correct class name)
        
        Returns:
            Improved code with original class name
        """
        original_class_name = self._extract_class_name(original_code)
        improved_class_name = self._extract_class_name(improved_code)
        
        if original_class_name != improved_class_name:
            logger.info(f"Replacing class name '{improved_class_name}' with '{original_class_name}'")
            # Replace class name in class declaration
            improved_code = re.sub(
                r'((?:public\s+)?class\s+)' + re.escape(improved_class_name) + r'\b',
                r'\1' + original_class_name,
                improved_code
            )
        
        return improved_code
    
    def generate_improvement_summary(self, analysis_result: Dict) -> str:
        """
        Generate summary of improvements made.
        
        Args:
            analysis_result: Analysis result from TestAnalyzerAgent
        
        Returns:
            Summary as formatted string
        """
        test_class_name = analysis_result.get('test_class_name', 'Unknown')
        overall_score = analysis_result.get('overall_compliance_score', 'N/A')
        
        summary = f"# Test Suite Improvement Summary\n"
        summary += f"## Test Class: {test_class_name}\n"
        summary += f"## Overall Compliance Score: {overall_score}\n\n"
        
        # Practices summary
        summary += "## Best Practices Compliance\n\n"
        
        practices_report = analysis_result.get('practices_report', [])
        if practices_report:
            for practice in practices_report:
                code = practice.get('practice_code', 'N/A')
                title = practice.get('practice_title', 'N/A')
                compliance = practice.get('compliance_score', 'N/A')
                summary += f"- **{code}**: {title} - {compliance}\n"
        else:
            summary += "*No practices report available*\n"
        
        # Method-level improvements
        summary += "\n## Method-Level Improvements\n\n"
        
        test_methods = analysis_result.get('test_methods', [])
        if test_methods:
            for method in test_methods:
                method_name = method.get('test_method_name', 'Unknown')
                method_score = method.get('method_compliance_score', 'N/A')
                summary += f"### {method_name} (Score: {method_score})\n\n"
                
                # List non-compliant practices
                practices_eval = method.get('practices_evaluation', [])
                non_compliant = [p for p in practices_eval if p.get('status') == '‚ùå']
                
                if non_compliant:
                    summary += "**Issues Found:**\n"
                    for practice in non_compliant:
                        code = practice.get('practice_code', 'N/A')
                        justification = practice.get('justification', 'N/A')
                        summary += f"- **{code}**: {justification}\n"
                    summary += "\n"
        else:
            summary += "*No method-level information available*\n"
        
        return summary
