{
  "version": "1.0.0",
  "last_updated": "2025-02-11",
  "source": "PhD Thesis: Towards a strategy and tool support for test generation based on good software testing practices",
  "author": "Camilo Hern√°n Villota Ibarra",
  "practices": [
    {
      "code": "CS-01",
      "title": "Especifica√ß√£o At√¥mica de Casos de Teste",
      "title_en": "Atomic Specification of Test Cases",
      "category": "Common Sense",
      "principle": "Cada teste deve focar em um √∫nico requisito ou comportamento.",
      "rationale": [
        "Facilita a identifica√ß√£o precisa da causa raiz de uma falha",
        "Evita a ocorr√™ncia de falsos positivos ou negativos",
        "Melhora a manutenibilidade e a legibilidade do conjunto de testes"
      ],
      "evaluation_criteria": {
        "positive": "O escopo do m√©todo de teste est√° claramente limitado a uma √∫nica funcionalidade ou cen√°rio",
        "negative": "O m√©todo de teste cont√©m m√∫ltiplos 'Arrange-Act-Assert' para diferentes funcionalidades, ou testa cria√ß√£o, atualiza√ß√£o e exclus√£o em uma √∫nica execu√ß√£o"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testUserOperations() {\n    // Testa cria√ß√£o, atualiza√ß√£o E exclus√£o no mesmo teste\n    createUser();\n    updateUser();\n    deleteUser();\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testCreateUser() { /* ... */ }\n\n@Test\npublic void testUpdateUser() { /* ... */ }\n\n@Test\npublic void testDeleteUser() { /* ... */ }"
        }
      }
    },
    {
      "code": "CS-02",
      "title": "Independ√™ncia Completa de Casos de Teste",
      "title_en": "Complete Independence of Test Cases",
      "category": "Common Sense",
      "principle": "Testes n√£o devem depender da execu√ß√£o de outros testes.",
      "rationale": [
        "Permite execu√ß√£o em qualquer ordem",
        "Facilita paraleliza√ß√£o",
        "Reduz efeitos colaterais entre testes"
      ],
      "evaluation_criteria": {
        "positive": "O teste possui seu pr√≥prio setup e n√£o depende de estado compartilhado de outros testes",
        "negative": "O teste depende de vari√°veis globais, estado de banco de dados ou execu√ß√£o pr√©via de outros testes"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void test1_createUser() {\n    user = new User(\"John\");\n}\n\n@Test\npublic void test2_updateUser() {\n    user.setName(\"Jane\"); // Depende de test1\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testUpdateUser() {\n    User user = new User(\"John\"); // Setup pr√≥prio\n    user.setName(\"Jane\");\n    assertEquals(\"Jane\", user.getName());\n}"
        }
      }
    },
    {
      "code": "CS-03",
      "title": "Cobertura de Fluxos Normais e Excepcionais",
      "title_en": "Coverage of Normal and Exceptional Flows",
      "category": "Common Sense",
      "principle": "Testar tanto cen√°rios normais quanto casos extremos e exce√ß√µes.",
      "rationale": [
        "Garante robustez do sistema",
        "Detecta edge cases",
        "Valida tratamento de erros"
      ],
      "evaluation_criteria": {
        "positive": "Existem testes separados para fluxos normais e excepcionais (exce√ß√µes, valores nulos, limites)",
        "negative": "Apenas fluxos normais s√£o testados, sem valida√ß√£o de tratamento de erros"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testDivision() {\n    assertEquals(2.0, calculator.divide(10, 5));\n    // Falta teste para divis√£o por zero\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testDivision_normalCase() {\n    assertEquals(2.0, calculator.divide(10, 5));\n}\n\n@Test(expected = ArithmeticException.class)\npublic void testDivision_divideByZero() {\n    calculator.divide(10, 0);\n}"
        }
      }
    },
    {
      "code": "CS-04",
      "title": "An√°lise de Valores Limite",
      "title_en": "Boundary Values Analysis",
      "category": "Common Sense",
      "principle": "Validar entradas nos limites m√≠nimo, m√°ximo e logo fora deles.",
      "rationale": [
        "Erros frequentemente ocorrem nos limites",
        "Detecta off-by-one errors",
        "Valida condi√ß√µes de contorno"
      ],
      "evaluation_criteria": {
        "positive": "Testes incluem valores nos limites (m√≠nimo, m√°ximo) e valores fora dos limites",
        "negative": "Testes usam apenas valores m√©dios, sem explorar limites"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testAgeValidation() {\n    assertTrue(isValidAge(25)); // Apenas valor m√©dio\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testAgeValidation() {\n    assertTrue(isValidAge(0));    // M√≠nimo\n    assertTrue(isValidAge(120));  // M√°ximo\n    assertFalse(isValidAge(-1));  // Abaixo do m√≠nimo\n    assertFalse(isValidAge(121)); // Acima do m√°ximo\n}"
        }
      }
    },
    {
      "code": "CS-05",
      "title": "Modularidade Completa de Casos de Teste",
      "title_en": "Complete Modularity of Test Cases",
      "category": "Common Sense",
      "principle": "Testes devem ser auto-contidos e reutiliz√°veis.",
      "rationale": [
        "Facilita manuten√ß√£o",
        "Permite reutiliza√ß√£o de componentes de teste",
        "Melhora legibilidade"
      ],
      "evaluation_criteria": {
        "positive": "Testes usam m√©todos auxiliares bem definidos e reutiliz√°veis (fixtures, helpers)",
        "negative": "C√≥digo duplicado entre testes, sem modulariza√ß√£o"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testA() {\n    Database db = new Database();\n    db.connect();\n    // teste...\n}\n\n@Test\npublic void testB() {\n    Database db = new Database();\n    db.connect(); // C√≥digo duplicado\n    // teste...\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Before\npublic void setUp() {\n    database = new Database();\n    database.connect();\n}\n\n@Test\npublic void testA() { /* usa database */ }\n\n@Test\npublic void testB() { /* usa database */ }"
        }
      }
    },
    {
      "code": "CS-06",
      "title": "An√°lise Detalhada de Tamanho e Complexidade",
      "title_en": "Detailed Analysis of Size and Complexity",
      "category": "Common Sense",
      "principle": "Manter testes pequenos e focados.",
      "rationale": [
        "Testes grandes s√£o dif√≠ceis de entender",
        "Complexidade dificulta debugging",
        "Testes simples s√£o mais confi√°veis"
      ],
      "evaluation_criteria": {
        "positive": "M√©todos de teste t√™m menos de 20 linhas e complexidade ciclom√°tica baixa",
        "negative": "M√©todos de teste muito longos (>50 linhas) ou com alta complexidade ciclom√°tica"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testComplexWorkflow() {\n    // 100+ linhas de c√≥digo\n    // M√∫ltiplos loops e condicionais\n    // Dif√≠cil de entender e manter\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testUserCreation() {\n    User user = service.createUser(\"John\");\n    assertNotNull(user);\n    assertEquals(\"John\", user.getName());\n}"
        }
      }
    },
    {
      "code": "CS-07",
      "title": "Design Complexo para Detec√ß√£o de Falhas",
      "title_en": "Complex Design for Fault Detection",
      "category": "Common Sense",
      "principle": "Alguns testes complexos s√£o necess√°rios para detectar problemas profundos.",
      "rationale": [
        "Bugs complexos requerem testes complexos",
        "Integra√ß√£o de m√∫ltiplos componentes precisa ser testada",
        "Balancear com CS-06"
      ],
      "evaluation_criteria": {
        "positive": "Existem testes de integra√ß√£o ou end-to-end que validam fluxos complexos quando necess√°rio",
        "negative": "Apenas testes unit√°rios simples, sem valida√ß√£o de cen√°rios complexos cr√≠ticos"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// Apenas testes unit√°rios isolados\n// Sem testes de integra√ß√£o para fluxos cr√≠ticos"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testCompleteCheckoutWorkflow() {\n    // Teste de integra√ß√£o validando:\n    // Carrinho -> Pagamento -> Estoque -> Notifica√ß√£o\n    // Complexidade justificada pela criticidade\n}"
        }
      }
    },
    {
      "code": "CS-08",
      "title": "Manuten√ß√£o Completa do C√≥digo de Teste",
      "title_en": "Complete Maintenance of Test Code",
      "category": "Common Sense",
      "principle": "C√≥digo de teste deve ser mantido com a mesma qualidade do c√≥digo de produ√ß√£o.",
      "rationale": [
        "Testes desatualizados s√£o in√∫teis",
        "Refatora√ß√£o deve incluir testes",
        "Qualidade do teste = qualidade do produto"
      ],
      "evaluation_criteria": {
        "positive": "Testes s√£o atualizados quando o c√≥digo de produ√ß√£o muda, seguem padr√µes de c√≥digo limpo",
        "negative": "Testes ignorados (commented out), desatualizados ou com c√≥digo de baixa qualidade"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// @Test\n// public void testOldFeature() {\n//     // Teste comentado em vez de removido/atualizado\n// }"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testNewFeature() {\n    // Teste atualizado para refletir mudan√ßas\n    // C√≥digo limpo e bem estruturado\n}"
        }
      }
    },
    {
      "code": "CS-09",
      "title": "Rastreabilidade Completa de Casos de Teste",
      "title_en": "Complete Traceability of Test Cases",
      "category": "Common Sense",
      "principle": "Cada teste deve estar vinculado a um requisito espec√≠fico.",
      "rationale": [
        "Facilita an√°lise de impacto",
        "Melhora gerenciamento de mudan√ßas",
        "Garante cobertura de requisitos"
      ],
      "evaluation_criteria": {
        "positive": "Testes incluem refer√™ncias a requisitos (via anota√ß√µes, coment√°rios ou naming conventions)",
        "negative": "Imposs√≠vel rastrear qual requisito um teste valida"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void test1() {\n    // Sem indica√ß√£o do requisito testado\n}"
        },
        "correct": {
          "language": "java",
          "code": "/**\n * Testa o requisito REQ-001: Sistema deve validar email\n * @requirement REQ-001\n */\n@Test\npublic void testEmailValidation_REQ001() { /* ... */ }"
        }
      }
    },
    {
      "code": "CS-10",
      "title": "Uso Rigoroso de Testes de Performance e Seguran√ßa",
      "title_en": "Strict Use of Performance and Security Testing",
      "category": "Common Sense",
      "principle": "Testes n√£o-funcionais devem ser separados dos funcionais.",
      "rationale": [
        "Requisitos diferentes",
        "Ferramentas espec√≠ficas",
        "Execu√ß√£o em ambientes distintos"
      ],
      "evaluation_criteria": {
        "positive": "Testes de performance e seguran√ßa est√£o em suites separadas com ferramentas apropriadas",
        "negative": "Testes de performance misturados com testes funcionais"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testUserCreation() {\n    long start = System.currentTimeMillis();\n    createUser();\n    long duration = System.currentTimeMillis() - start;\n    assertTrue(duration < 100); // Performance test misturado\n}"
        },
        "correct": {
          "language": "java",
          "code": "// Suite funcional\n@Test\npublic void testUserCreation() { /* ... */ }\n\n// Suite de performance separada (JMeter, Gatling, etc.)\n@PerformanceTest\npublic void testUserCreationPerformance() { /* ... */ }"
        }
      }
    },
    {
      "code": "CS-11",
      "title": "Revis√£o Regular de Casos de Teste",
      "title_en": "Regular Review of Test Cases",
      "category": "Common Sense",
      "principle": "Testes devem ser revisados periodicamente.",
      "rationale": [
        "Requisitos mudam",
        "C√≥digo evolui",
        "Testes obsoletos devem ser removidos"
      ],
      "evaluation_criteria": {
        "positive": "Evid√™ncias de revis√£o peri√≥dica (commits de atualiza√ß√£o, remo√ß√£o de testes obsoletos)",
        "negative": "Testes nunca atualizados, acumula√ß√£o de testes obsoletos"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// Testes de 2015 nunca revisados\n// Testando features que n√£o existem mais"
        },
        "correct": {
          "language": "java",
          "code": "// Testes atualizados regularmente\n// Testes obsoletos removidos\n// Documenta√ß√£o de quando e por que foram atualizados"
        }
      }
    },
    {
      "code": "CS-12",
      "title": "Compreens√£o Clara de Casos de Teste",
      "title_en": "Clear Understanding of Test Cases",
      "category": "Common Sense",
      "principle": "Cada teste deve ter prop√≥sito claro e inequ√≠voco.",
      "rationale": [
        "Facilita manuten√ß√£o",
        "Melhora comunica√ß√£o",
        "Reduz ambiguidade"
      ],
      "evaluation_criteria": {
        "positive": "Nomes de testes descritivos, coment√°rios explicativos quando necess√°rio",
        "negative": "Nomes gen√©ricos (test1, test2) ou prop√≥sito do teste n√£o √© claro"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void test1() {\n    // O que este teste valida?\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testUserRegistration_shouldSendWelcomeEmail() {\n    // Prop√≥sito claro no nome\n}"
        }
      }
    },
    {
      "code": "CS-13",
      "title": "Cobertura Estruturada do Processo de Teste",
      "title_en": "Structured Coverage of Testing Process",
      "category": "Common Sense",
      "principle": "Usar abordagens estruturadas (top-down, bottom-up) para testes de integra√ß√£o.",
      "rationale": [
        "Garante cobertura sistem√°tica",
        "Facilita identifica√ß√£o de problemas de integra√ß√£o",
        "Melhora planejamento de testes"
      ],
      "evaluation_criteria": {
        "positive": "Estrat√©gia clara de integra√ß√£o (top-down, bottom-up, ou sandwich)",
        "negative": "Testes de integra√ß√£o ad-hoc sem estrat√©gia definida"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// Testes de integra√ß√£o aleat√≥rios\n// Sem ordem ou estrat√©gia clara"
        },
        "correct": {
          "language": "java",
          "code": "// Estrat√©gia bottom-up:\n// 1. Testar camada de dados\n// 2. Testar camada de neg√≥cio\n// 3. Testar camada de apresenta√ß√£o\n// 4. Testar integra√ß√£o completa"
        }
      }
    },
    {
      "code": "CS-14",
      "title": "Garantia Completa da Qualidade do C√≥digo de Teste",
      "title_en": "Complete Assurance of Test Code Quality",
      "category": "Common Sense",
      "principle": "Usar m√©tricas de cobertura, mas n√£o depender apenas delas.",
      "rationale": [
        "100% cobertura ‚â† 100% qualidade",
        "M√©tricas s√£o indicadores, n√£o garantias",
        "Qualidade > quantidade"
      ],
      "evaluation_criteria": {
        "positive": "Uso de m√∫ltiplas m√©tricas (cobertura, mutation score, an√°lise est√°tica)",
        "negative": "Depend√™ncia exclusiva de cobertura de c√≥digo como m√©trica de qualidade"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// \"Temos 100% de cobertura, ent√£o estamos seguros!\"\n// Mas testes sem asser√ß√µes ou com asser√ß√µes fracas"
        },
        "correct": {
          "language": "java",
          "code": "// Combinar:\n// - Cobertura de c√≥digo (>80%)\n// - Mutation score (>70%)\n// - Code review de testes\n// - An√°lise de qualidade de asser√ß√µes"
        }
      }
    },
    {
      "code": "LS-01",
      "title": "Utiliza√ß√£o Adequada de Cobertura de C√≥digo",
      "title_en": "Proper Utilization of Test Code Coverage",
      "category": "Literature Supported",
      "principle": "Alta cobertura n√£o significa necessariamente testes efetivos.",
      "rationale": [
        "Cobertura mede execu√ß√£o, n√£o qualidade",
        "Poss√≠vel ter 100% cobertura com asser√ß√µes fracas",
        "Foco deve ser em qualidade, n√£o apenas quantidade"
      ],
      "evaluation_criteria": {
        "positive": "Testes com alta cobertura E asser√ß√µes significativas que validam comportamento",
        "negative": "Alta cobertura mas testes sem asser√ß√µes ou com asser√ß√µes triviais"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testCalculator() {\n    calculator.add(2, 2); // Executa o c√≥digo\n    // Sem asser√ß√£o! Cobertura alta, qualidade baixa\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testCalculator() {\n    int result = calculator.add(2, 2);\n    assertEquals(4, result); // Valida o comportamento\n}"
        }
      }
    },
    {
      "code": "LS-02",
      "title": "Utiliza√ß√£o Necess√°ria de Testes Ausentes",
      "title_en": "Required Utilization of Missing Tests",
      "category": "Literature Supported",
      "principle": "Identificar gaps na cobertura e criar testes faltantes.",
      "rationale": [
        "C√≥digo n√£o testado √© c√≥digo n√£o confi√°vel",
        "Bugs frequentemente aparecem em √°reas n√£o testadas",
        "An√°lise de gaps √© essencial"
      ],
      "evaluation_criteria": {
        "positive": "Processo sistem√°tico de identifica√ß√£o e cria√ß√£o de testes para gaps de cobertura",
        "negative": "√Åreas cr√≠ticas do c√≥digo sem testes"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// M√©todo cr√≠tico de pagamento sem testes\npublic void processPayment(Payment p) {\n    // C√≥digo n√£o testado\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testProcessPayment_validCard() { /* ... */ }\n\n@Test\npublic void testProcessPayment_invalidCard() { /* ... */ }\n\n@Test\npublic void testProcessPayment_insufficientFunds() { /* ... */ }"
        }
      }
    },
    {
      "code": "LS-03",
      "title": "Utiliza√ß√£o Eficiente de Cobertura de C√≥digo",
      "title_en": "Efficient Utilization of Test Code Coverage",
      "category": "Literature Supported",
      "principle": "Cobertura deve incluir padr√µes de falha e casos extremos.",
      "rationale": [
        "N√£o basta executar o c√≥digo",
        "Necess√°rio testar condi√ß√µes de erro",
        "Edge cases revelam bugs ocultos"
      ],
      "evaluation_criteria": {
        "positive": "Testes cobrem branches de erro, valores nulos, strings vazias, listas vazias, etc.",
        "negative": "Cobertura apenas de happy paths, ignorando edge cases"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testProcessString() {\n    assertEquals(\"HELLO\", processor.process(\"hello\"));\n    // Falta testar null, string vazia, caracteres especiais\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testProcessString_normal() { /* ... */ }\n\n@Test\npublic void testProcessString_emptyString() { /* ... */ }\n\n@Test\npublic void testProcessString_nullString() { /* ... */ }\n\n@Test\npublic void testProcessString_specialCharacters() { /* ... */ }"
        }
      }
    },
    {
      "code": "LS-04",
      "title": "Pegada Pequena de Gera√ß√£o de C√≥digo de Teste",
      "title_en": "Small Test Code Generation Footprint",
      "category": "Literature Supported",
      "principle": "Testes devem executar rapidamente e evitar computa√ß√µes desnecess√°rias.",
      "rationale": [
        "Testes lentos desencorajam execu√ß√£o frequente",
        "Feedback r√°pido √© essencial",
        "Suites grandes devem executar em minutos, n√£o horas"
      ],
      "evaluation_criteria": {
        "positive": "Testes unit√°rios executam em milissegundos, uso de mocks para depend√™ncias externas",
        "negative": "Testes lentos devido a I/O desnecess√°rio, chamadas de rede, ou opera√ß√µes pesadas"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testUserService() {\n    // Conecta ao banco de dados real\n    // Faz chamadas HTTP reais\n    // L√™ arquivos do disco\n    // Teste lento (segundos)\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testUserService() {\n    // Usa mocks para depend√™ncias\n    UserRepository mockRepo = mock(UserRepository.class);\n    UserService service = new UserService(mockRepo);\n    // Teste r√°pido (milissegundos)\n}"
        }
      }
    },
    {
      "code": "LS-05",
      "title": "Prioriza√ß√£o Completa do Design de Casos de Teste",
      "title_en": "Complete Prioritization of Test Cases Design",
      "category": "Literature Supported",
      "principle": "Priorizar testes baseado em requisitos funcionais e n√£o-funcionais.",
      "rationale": [
        "Recursos limitados",
        "Alguns testes s√£o mais cr√≠ticos",
        "ROI de testes varia"
      ],
      "evaluation_criteria": {
        "positive": "Testes cr√≠ticos executados primeiro, estrat√©gia clara de prioriza√ß√£o",
        "negative": "Todos os testes tratados com mesma prioridade, sem estrat√©gia"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// Todos os testes executados em ordem alfab√©tica\n// Sem distin√ß√£o entre cr√≠ticos e n√£o-cr√≠ticos"
        },
        "correct": {
          "language": "java",
          "code": "// Suite 1: Testes cr√≠ticos (smoke tests)\n// Suite 2: Testes de regress√£o\n// Suite 3: Testes completos\n// Prioriza√ß√£o baseada em criticidade e frequ√™ncia de falha"
        }
      }
    },
    {
      "code": "LS-06",
      "title": "Adi√ß√£o Respons√°vel de Manuten√ß√£o de C√≥digo de Teste",
      "title_en": "Responsible Addition of Test Code Maintenance",
      "category": "Literature Supported",
      "principle": "Manter suite atualizada com bugs corrigidos (regression tests).",
      "rationale": [
        "Bugs corrigidos podem reaparecer",
        "Testes de regress√£o previnem reintrodu√ß√£o",
        "Documentam comportamento esperado"
      ],
      "evaluation_criteria": {
        "positive": "Para cada bug corrigido, existe um teste de regress√£o correspondente",
        "negative": "Bugs corrigidos sem testes de regress√£o"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// Bug #1234 corrigido\n// Mas nenhum teste adicionado para prevenir regress√£o"
        },
        "correct": {
          "language": "java",
          "code": "/**\n * Regression test for Bug #1234\n * Sistema travava ao processar string com emoji\n */\n@Test\npublic void testProcessString_withEmoji_Bug1234() {\n    String result = processor.process(\"Hello üòÄ\");\n    assertNotNull(result);\n}"
        }
      }
    },
    {
      "code": "LS-07",
      "title": "Utiliza√ß√£o Adequada de Asser√ß√µes de Teste",
      "title_en": "Suitable Utilization of Test Assertions",
      "category": "Literature Supported",
      "principle": "Usar asser√ß√µes efetivamente para detectar falhas sutis.",
      "rationale": [
        "Asser√ß√µes s√£o o cora√ß√£o dos testes",
        "Asser√ß√µes fracas n√£o detectam problemas",
        "M√∫ltiplas asser√ß√µes podem ser necess√°rias"
      ],
      "evaluation_criteria": {
        "positive": "Asser√ß√µes espec√≠ficas e significativas que validam todos os aspectos relevantes",
        "negative": "Asser√ß√µes gen√©ricas (assertTrue(true)) ou aus√™ncia de asser√ß√µes"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testUserCreation() {\n    User user = service.createUser(\"John\", \"john@example.com\");\n    assertTrue(user != null); // Asser√ß√£o fraca\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testUserCreation() {\n    User user = service.createUser(\"John\", \"john@example.com\");\n    assertNotNull(user);\n    assertNotNull(user.getId());\n    assertEquals(\"John\", user.getName());\n    assertEquals(\"john@example.com\", user.getEmail());\n    assertTrue(user.isActive());\n}"
        }
      }
    },
    {
      "code": "LS-08",
      "title": "Adi√ß√£o Respons√°vel de Coment√°rios de Depura√ß√£o",
      "title_en": "Responsible Addition of Test Debugging Comments",
      "category": "Literature Supported",
      "principle": "Documentar padr√µes de falha e comportamentos esperados.",
      "rationale": [
        "Facilita debugging",
        "Explica inten√ß√£o do teste",
        "Ajuda futuros mantenedores"
      ],
      "evaluation_criteria": {
        "positive": "Coment√°rios explicam o porqu√™ do teste, n√£o o qu√™ (que deve estar claro no c√≥digo)",
        "negative": "Testes sem documenta√ß√£o ou com coment√°rios in√∫teis"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testX() {\n    // Testa X\n    // Coment√°rio √≥bvio e in√∫til\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testConcurrentAccess() {\n    // Bug #1234: Sistema travava com acessos simult√¢neos\n    // Este teste garante que o lock funciona corretamente\n    // Esperado: Ambas threads completam sem deadlock\n    /* ... */\n}"
        }
      }
    },
    {
      "code": "LS-09",
      "title": "Design Determin√≠stico de Resultados de Teste",
      "title_en": "Deterministic Design of Test Results",
      "category": "Literature Supported",
      "principle": "Testes devem sempre retornar os mesmos resultados dados os mesmos inputs.",
      "rationale": [
        "Testes flaky s√£o in√∫teis",
        "N√£o-determinismo dificulta debugging",
        "Confian√ßa na suite de testes"
      ],
      "evaluation_criteria": {
        "positive": "Testes s√£o determin√≠sticos, sem depend√™ncia de tempo real, ordem de execu√ß√£o ou estado externo",
        "negative": "Testes flaky que falham intermitentemente"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testTimestamp() {\n    long timestamp = System.currentTimeMillis();\n    // Resultado varia a cada execu√ß√£o\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Test\npublic void testTimestamp() {\n    Clock fixedClock = Clock.fixed(\n        Instant.parse(\"2024-01-01T00:00:00Z\"),\n        ZoneId.of(\"UTC\")\n    );\n    long timestamp = fixedClock.millis();\n    // Resultado sempre o mesmo\n}"
        }
      }
    },
    {
      "code": "LS-10",
      "title": "Evitar Completamente Efeitos Colaterais de Teste",
      "title_en": "Complete Avoidance of Test Side Effects",
      "category": "Literature Supported",
      "principle": "Testes n√£o devem modificar estado compartilhado ou causar depend√™ncias.",
      "rationale": [
        "Efeitos colaterais causam falhas intermitentes",
        "Dificulta paraleliza√ß√£o",
        "Viola independ√™ncia (CS-02)"
      ],
      "evaluation_criteria": {
        "positive": "Testes isolam estado, usam setup/teardown apropriados",
        "negative": "Testes modificam vari√°veis globais, arquivos compartilhados, ou estado de banco de dados"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "@Test\npublic void testA() {\n    GlobalState.counter++; // Modifica estado global\n}\n\n@Test\npublic void testB() {\n    assertEquals(0, GlobalState.counter); // Pode falhar se testA executou antes\n}"
        },
        "correct": {
          "language": "java",
          "code": "@Before\npublic void setUp() {\n    database = new InMemoryDatabase();\n}\n\n@After\npublic void tearDown() {\n    database.clear();\n}"
        }
      }
    },
    {
      "code": "LS-11",
      "title": "Utiliza√ß√£o Adequada de R√≥tulos e Categorias",
      "title_en": "Suitable Utilization of Test Labels and Categories",
      "category": "Literature Supported",
      "principle": "Organizar testes com labels e categorias.",
      "rationale": [
        "Facilita execu√ß√£o seletiva",
        "Permite separar testes r√°pidos/lentos",
        "Melhora organiza√ß√£o da suite"
      ],
      "evaluation_criteria": {
        "positive": "Testes categorizados (unit, integration, e2e) e com tags apropriadas",
        "negative": "Todos os testes misturados sem organiza√ß√£o"
      },
      "examples": {
        "violation": {
          "language": "java",
          "code": "// Todos os testes na mesma suite\n// Sem distin√ß√£o entre unit√°rios e de integra√ß√£o"
        },
        "correct": {
          "language": "java",
          "code": "@Category(UnitTest.class)\n@Test\npublic void testBusinessLogic() { /* ... */ }\n\n@Category(IntegrationTest.class)\n@Test\npublic void testDatabaseIntegration() { /* ... */ }\n\n@Category({SlowTest.class, IntegrationTest.class})\n@Test\npublic void testFullWorkflow() { /* ... */ }"
        }
      }
    }
  ]
}
